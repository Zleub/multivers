<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

  <title>client</title>
  <meta name="description" content="client description">

  <style>
  body {
    font-family: Monospace;
    background-color: #000;
    color: #fff;
    margin: 0px;
    overflow: hidden;
  }
  #blocker {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }
  #instructions {
    width: 100%;
    height: 100%;
    display: -webkit-box;
    display: -moz-box;
    display: box;
    -webkit-box-orient: horizontal;
    -moz-box-orient: horizontal;
    box-orient: horizontal;
    -webkit-box-pack: center;
    -moz-box-pack: center;
    box-pack: center;
    -webkit-box-align: center;
    -moz-box-align: center;
    box-align: center;
    color: #ffffff;
    text-align: center;
    cursor: pointer;
  }
  </style>

  <script type="text/javascript" src="https://threejs.org/build/three.js"></script>
  <script type="text/javascript" src="FirstPersonControls.js"></script>
  <script type="text/javascript" src="OrbitControls.js"></script>
  <script type="text/javascript" src="PointerLockControls.js"></script>
  <script type="text/javascript" src="util.js"></script>
  <script type="text/javascript" src="dat.gui.min.js"></script>
</head>
<body>
  <!-- <div id="blocker">

    <div id="instructions">
      <span style="font-size:40px">Click to play</span>
      <br />
      (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
    </div>

  </div> -->

  <script>
    var run = true
  // var blocker = document.getElementById( 'blocker' );
	// var instructions = document.getElementById( 'instructions' );
  //
  // var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
  // if ( havePointerLock ) {
  //   var element = document.body;
  //   var pointerlockchange = function ( event ) {
  //     if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
  //       controlsEnabled = true;
  //       controls.enabled = true;
  //       blocker.style.display = 'none';
  //       console.log(controls.enabled)
  //     } else {
  //       controls.enabled = false;
  //       blocker.style.display = 'block';
  //       instructions.style.display = '';
  //     }
  //   };
  //   var pointerlockerror = function ( event ) {
  //     console.log('errrr')
  //     instructions.style.display = '';
  //   };
  //   // Hook pointer lock state change events
  //   document.addEventListener( 'pointerlockchange', pointerlockchange, false );
  //   document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
  //   document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
  //   document.addEventListener( 'pointerlockerror', pointerlockerror, false );
  //   document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
  //   document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
  //   instructions.addEventListener( 'click', function ( event ) {
  //     instructions.style.display = 'none';
  //       // Ask the browser to lock the pointer
  //     element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
  //     element.requestPointerLock();
  //   }, false );
  // } else {
  //   instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
  // }

  var objects = []

  var controlsEnabled = false;
  var moveForward = false;
  var moveBackward = false;
  var moveLeft = false;
  var moveRight = false;
  var canJump = false;
  var prevTime = performance.now();
  var velocity = new THREE.Vector3();
  var direction = new THREE.Vector3();
  var vertex = new THREE.Vector3();
  var color = new THREE.Color();
  var camera, scene, renderer, stats;
  var pointLights = []

  function createLight( color ) {
      var intensity = 1.5;
      var pointLight = new THREE.PointLight( color, intensity, 20 );
      pointLight.castShadow = true;
      pointLight.shadow.camera.near = 1;
      pointLight.shadow.camera.far = 60;
      pointLight.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects
      var geometry = new THREE.SphereBufferGeometry( 0.6, 12, 6 );
      var material = new THREE.MeshBasicMaterial( { color: color } );
      material.color.multiplyScalar( intensity );
      var sphere = new THREE.Mesh( geometry, material );
      pointLight.add( sphere );
      var texture = new THREE.CanvasTexture( generateTexture() );
      texture.magFilter = THREE.NearestFilter;
      texture.wrapT = THREE.RepeatWrapping;
      texture.wrapS = THREE.RepeatWrapping;
      texture.repeat.set( 1, 3.5 );
      var geometry = new THREE.SphereBufferGeometry( 1.5, 32, 8 );
      var material = new THREE.MeshPhongMaterial( {
        side: THREE.DoubleSide,
        alphaMap: texture,
        alphaTest: 0.5
      } );
      var sphere = new THREE.Mesh( geometry, material );
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      pointLight.add( sphere );
      // custom distance material
      var distanceMaterial = new THREE.MeshDistanceMaterial( {
        alphaMap: material.alphaMap,
        alphaTest: material.alphaTest
      } );
      sphere.customDistanceMaterial = distanceMaterial;
      return pointLight;
    }

  function generateTexture() {
    var canvas = document.createElement( 'canvas' );
    canvas.width = 2;
    canvas.height = 2;
    var context = canvas.getContext( '2d' );
    context.fillStyle = 'white';
    context.fillRect( 0, 1, 2, 1 );
    return canvas;
  }

  function render() {
    var time = performance.now() * 0.001;
    pointLights.forEach(e => {
      e.position.x = Math.sin( time * 0.6 ) * 16
      e.position.y = Math.sin( time * 0.7 ) * 16
      e.position.z = Math.sin( time * 0.8 ) * 16

      e.rotation.x = time;
      e.rotation.z = time;
      time += 10000;
    })

    // camera.position.x = Math.sin( time * 0.05 ) * 150
    // camera.position.z = Math.cos( time * 0.05 ) * 150

    renderer.render(scene, camera)
  }

  // camera.position.set( 0, 100, 100 );


  // camera.position.set( 0, 1, 0 );

  scene = new THREE.Scene();
  scene.add( new THREE.AmbientLight( 0x6f6f6f ) );


  camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
  var controls = new THREE.PointerLockControls( camera );
  scene.add( controls.getObject() )
  controls.getObject().position.set(0, 10, 0)

  // pointLights.push( createLight( 0x0088ff, 4, 100 ) )
  // pointLights.forEach(e => {
  //   e.position.set( 0, 10, 0 );
  //   scene.add( e );
  // })

  var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
  var materialGray = new THREE.MeshLambertMaterial( {
    color: 0xa0adaf,
    wireframe: false
  } );
  var materialGreen = new THREE.MeshLambertMaterial( {
    color: 0xa0ddaf,
    wireframe: false
  } );
  var materialGreenMore = new THREE.MeshLambertMaterial( {
    color: 0x60bd6f,
    wireframe: false
  } );
  var materialBlue = new THREE.MeshLambertMaterial( {
    color: 0x4d4fd0,
    wireframe: false
  } );

  var Cubecount = 0

  fetchMultivers('/sharpen').then( res => res.json().then( e => {
    // console.log(e)
    e.add.forEach(_ => {
      // var _geometry = geometry.toNonIndexed();
      var mesh
      if (_.y < 4)
        mesh = new THREE.Mesh( geometry, materialBlue )
      else if (_.y > 10)
        mesh = new THREE.Mesh( geometry, materialGray )
      else if (_.y > 5)
        mesh = new THREE.Mesh( geometry, materialGreenMore )
      else
        mesh = new THREE.Mesh( geometry, materialGreen )

        Cubecount += 1
      mesh.position.x = _.x - e.position[0];
      mesh.position.y = _.y;
      mesh.position.z = _.z - e.position[1];
      mesh.receiveShadow = true;

      // mesh.castShadow = true;
      // mesh.receiveShadow = true;

      scene.add( mesh );
      objects.push( mesh )

          // if (_.name == 'wall') {
          //   var _material = new THREE.MeshPhongMaterial( {
          //     color: 0x606d6f,
          //     // wireframe: false
          //   } );
          //   for (var i = 0; i < 4; i++) {
          //     var mesh = new THREE.Mesh( geometry, _material );
          //     mesh.position.x = _.x - e.position[0];
          //     mesh.position.y = i
          //     mesh.position.z = _.y - e.position[1];
          //     mesh.receiveShadow = true;
          //     mesh.castShadow = true;
          //     scene.add( mesh );
          //   }
          // }

    })

    // var element = document.body
    // console.log( element.requestPointerLock() )

    animate()
    // render();

  }))

  var pointerlockchange = function ( event ) {
      console.log('pointerlockchange')
      controlsEnabled = !controlsEnabled;
      controls.enabled = !controls.enabled;
  };
  document.addEventListener( 'pointerlockchange', pointerlockchange, false );



  renderer = new THREE.WebGLRenderer( { antialias: true } );

  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.BasicShadowMap;
  document.body.appendChild( renderer.domElement );

  // var controls = new THREE.OrbitControls(camera, renderer.domElement)
  //
  // controls.update();
  //
  // function animate() {
  //
  // 	requestAnimationFrame( animate );
  //
  //   if (!run)
  //     return
  //
  //   controls.update();
  //   render();
  //
  // }


  var raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, -1, 0 ), 0, 2 );

  var onKeyDown = function ( event ) {
		switch ( event.keyCode ) {
			case 38: // up
			case 87: // w
				moveForward = true;
				break;
			case 37: // left
			case 65: // a
				moveLeft = true; break;
			case 40: // down
			case 83: // s
				moveBackward = true;
				break;
			case 39: // right
			case 68: // d
				moveRight = true;
				break;
			case 32: // space
				if ( canJump === true ) velocity.y += 80;
				canJump = false;
				break;
		}
	};
	var onKeyUp = function ( event ) {
		switch( event.keyCode ) {
			case 38: // up
			case 87: // w
				moveForward = false;
				break;
			case 37: // left
			case 65: // a
				moveLeft = false;
				break;
			case 40: // down
			case 83: // s
				moveBackward = false;
				break;
			case 39: // right
			case 68: // d
				moveRight = false;
				break;
		}
	};
	document.addEventListener( 'keydown', onKeyDown, false );
	document.addEventListener( 'keyup', onKeyUp, false );
  //
  var gui = new dat.GUI({name: 'My GUI'});
  gui.add(window, 'run')
  gui.add(window, 'Cubecount').listen()
  //

  // gui.add(controls.getObject().position, 'x').listen()
  // gui.add(controls.getObject().position, 'y').listen()
  // gui.add(controls.getObject().position, 'z').listen()
  //
  var clock = new THREE.Clock()
  function animate() {
    requestAnimationFrame( animate );

    // var delta = clock.getDelta()

    if ( controlsEnabled === true ) {
      raycaster.ray.origin.copy( controls.getObject().position );
      // raycaster.ray.origin.y -= 2;
      var intersections = raycaster.intersectObjects( objects );
      var onObject = intersections.length > 0;
      var time = performance.now();
      // var delta = ( time - prevTime ) / 3000;
      var delta = 0.01;
      // console.log(delta)
      velocity.x -= velocity.x * 10 * delta;
      velocity.z -= velocity.z * 10 * delta;
      velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
      direction.z = Number( moveForward ) - Number( moveBackward );
      direction.x = Number( moveLeft ) - Number( moveRight );
      direction.normalize(); // this ensures consistent movements in all directions
      if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
      if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
      if ( onObject === true ) {
        velocity.y = Math.max( 0, velocity.y );
        controls.getObject().position.y = intersections[0].object.position.y + intersections[0].object.scale.y + 1
        canJump = true;
      }
      controls.getObject().translateX( velocity.x * delta );
      controls.getObject().translateY( velocity.y * delta );
      controls.getObject().translateZ( velocity.z * delta );
      // if ( controls.getObject().position.y < 1 ) {
      //   velocity.y = 0;
      //   controls.getObject().position.y = 1;
      //   canJump = true;
      // }
      prevTime = time;
    }
    else {
      // document.body.requestPointerLock()
    }

    render();
  }

  </script>
</body>

</html>
