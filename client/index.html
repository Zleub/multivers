<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

  <title>client</title>
  <meta name="description" content="client description">

  <style>
  body {
    font-family: Monospace;
    background-color: #000;
    color: #fff;
    margin: 0px;
    overflow: hidden;
  }
  #blocker {
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
}
  </style>

  <script type="text/javascript" src="https://threejs.org/build/three.js"></script>
  <script type="text/javascript" src="FirstPersonControls.js"></script>
  <script type="text/javascript" src="OrbitControls.js"></script>
  <script type="text/javascript" src="PointerLockControls.js"></script>
  <script type="text/javascript" src="src/client-app/util.js"></script>
  <script type="text/javascript" src="dat.gui.min.js"></script>
</head>
<body>
  <!-- <div id="blocker">

    <div id="instructions">
      <span style="font-size:40px">Click to play</span>
      <br />
      (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
    </div>

  </div> -->

  <script>
    var run = true
  // var blocker = document.getElementById( 'blocker' );
	// var instructions = document.getElementById( 'instructions' );
  //
  // var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
  // if ( havePointerLock ) {
  //   var element = document.body;
  //   var pointerlockchange = function ( event ) {
  //     if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
  //       controlsEnabled = true;
  //       controls.enabled = true;
  //       blocker.style.display = 'none';
  //       console.log(controls.enabled)
  //     } else {
  //       controls.enabled = false;
  //       blocker.style.display = 'block';
  //       instructions.style.display = '';
  //     }
  //   };
  //   var pointerlockerror = function ( event ) {
  //     console.log('errrr')
  //     instructions.style.display = '';
  //   };
  //   // Hook pointer lock state change events
  //   document.addEventListener( 'pointerlockchange', pointerlockchange, false );
  //   document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
  //   document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
  //   document.addEventListener( 'pointerlockerror', pointerlockerror, false );
  //   document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
  //   document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
  //   instructions.addEventListener( 'click', function ( event ) {
  //     instructions.style.display = 'none';
  //       // Ask the browser to lock the pointer
  //     element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
  //     element.requestPointerLock();
  //   }, false );
  // } else {
  //   instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
  // }

  var objects = []

  var controlsEnabled = false;
  var moveForward = false;
  var moveBackward = false;
  var moveLeft = false;
  var moveRight = false;
  var canJump = false;
  var prevTime = performance.now();
  var velocity = new THREE.Vector3();
  var direction = new THREE.Vector3();
  var vertex = new THREE.Vector3();
  var color = new THREE.Color();
  var camera, scene, renderer, stats;
  var pointLights = []

  function createLight( color ) {
      var intensity = 1.5;
      var pointLight = new THREE.PointLight( color, intensity, 20 );
      pointLight.castShadow = true;
      pointLight.shadow.camera.near = 1;
      pointLight.shadow.camera.far = 60;
      pointLight.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects
      var geometry = new THREE.SphereBufferGeometry( 0.6, 12, 6 );
      var material = new THREE.MeshBasicMaterial( { color: color } );
      material.color.multiplyScalar( intensity );
      var sphere = new THREE.Mesh( geometry, material );
      pointLight.add( sphere );
      var texture = new THREE.CanvasTexture( generateTexture() );
      texture.magFilter = THREE.NearestFilter;
      texture.wrapT = THREE.RepeatWrapping;
      texture.wrapS = THREE.RepeatWrapping;
      texture.repeat.set( 1, 3.5 );
      var geometry = new THREE.SphereBufferGeometry( 1.5, 32, 8 );
      var material = new THREE.MeshPhongMaterial( {
        side: THREE.DoubleSide,
        alphaMap: texture,
        alphaTest: 0.5
      } );
      var sphere = new THREE.Mesh( geometry, material );
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      pointLight.add( sphere );
      // custom distance material
      var distanceMaterial = new THREE.MeshDistanceMaterial( {
        alphaMap: material.alphaMap,
        alphaTest: material.alphaTest
      } );
      sphere.customDistanceMaterial = distanceMaterial;
      return pointLight;
    }

  function generateTexture() {
    var canvas = document.createElement( 'canvas' );
    canvas.width = 2;
    canvas.height = 2;
    var context = canvas.getContext( '2d' );
    context.fillStyle = 'white';
    context.fillRect( 0, 1, 2, 1 );
    return canvas;
  }

  function render() {
    var time = performance.now() * 0.001;
    pointLights.forEach(e => {
      e.position.x = Math.sin( time * 0.6 ) * 16
      e.position.y = Math.sin( time * 0.7 ) * 16
      e.position.z = Math.sin( time * 0.8 ) * 16

      e.rotation.x = time;
      e.rotation.z = time;
      time += 10000;
    })

    renderer.render(scene, camera)
  }

  camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
  // camera.position.set( 0, 1, 0 );

  scene = new THREE.Scene();
  scene.add( new THREE.AmbientLight( 0x6f6f6f ) );

  var light = createLight( 0x0088ff, 4, 100 );
  light.position.set( 0, 10, 0 );
  scene.add( light );
  pointLights.push( light )
  light = createLight( 0x88ff88, 4, 100 );
  light.position.set( 0, 10, 0 );
  scene.add( light );
  pointLights.push( light )

  var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
  var material = new THREE.MeshLambertMaterial( {
    color: 0xa0adaf,
    // wireframe: true
  } );

  fetchMultivers('/world').then( res => res.json().then( e => {
    console.log(e)
    e.add.forEach(_ => {
      // var _geometry = geometry.toNonIndexed();
      var mesh = new THREE.Mesh( geometry, material );
      mesh.position.x = _.x - e.position[0];
      mesh.position.y = _.y;
      mesh.position.z = _.z - e.position[1];
      mesh.receiveShadow = true;

      // mesh.castShadow = true;
      // mesh.receiveShadow = true;

      scene.add( mesh );
      objects.push( mesh )

          // if (_.name == 'wall') {
          //   var _material = new THREE.MeshPhongMaterial( {
          //     color: 0x606d6f,
          //     // wireframe: true
          //   } );
          //   for (var i = 0; i < 4; i++) {
          //     var mesh = new THREE.Mesh( geometry, _material );
          //     mesh.position.x = _.x - e.position[0];
          //     mesh.position.y = i
          //     mesh.position.z = _.y - e.position[1];
          //     mesh.receiveShadow = true;
          //     mesh.castShadow = true;
          //     scene.add( mesh );
          //   }
          // }

    })

    animate()
    render();
  }))

  renderer = new THREE.WebGLRenderer( { antialias: true } );

  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.BasicShadowMap;
  document.body.appendChild( renderer.domElement );

  var controls = new THREE.OrbitControls(camera, renderer.domElement)

  camera.position.set( 0, 50, 100 );
  controls.update();

  function animate() {

  	requestAnimationFrame( animate );

    if (!run)
      return

    controls.update();
    render();

  }


    // var controls = new THREE.PointerLockControls( camera );
  // scene.add( controls.getObject() )
  // var raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 2 );
  //
  // var onKeyDown = function ( event ) {
	// 	switch ( event.keyCode ) {
	// 		case 38: // up
	// 		case 87: // w
	// 			moveForward = true;
	// 			break;
	// 		case 37: // left
	// 		case 65: // a
	// 			moveLeft = true; break;
	// 		case 40: // down
	// 		case 83: // s
	// 			moveBackward = true;
	// 			break;
	// 		case 39: // right
	// 		case 68: // d
	// 			moveRight = true;
	// 			break;
	// 		case 32: // space
	// 			if ( canJump === true ) velocity.y += 80;
	// 			canJump = false;
	// 			break;
	// 	}
	// };
	// var onKeyUp = function ( event ) {
	// 	switch( event.keyCode ) {
	// 		case 38: // up
	// 		case 87: // w
	// 			moveForward = false;
	// 			break;
	// 		case 37: // left
	// 		case 65: // a
	// 			moveLeft = false;
	// 			break;
	// 		case 40: // down
	// 		case 83: // s
	// 			moveBackward = false;
	// 			break;
	// 		case 39: // right
	// 		case 68: // d
	// 			moveRight = false;
	// 			break;
	// 	}
	// };
	// document.addEventListener( 'keydown', onKeyDown, false );
	// document.addEventListener( 'keyup', onKeyUp, false );
  //
  var gui = new dat.GUI({name: 'My GUI'});
  gui.add(window, 'run')
  //
  // controls.getObject().position.set(0, 2, 0)
  // gui.add(controls.getObject().position, 'x').listen()
  // gui.add(controls.getObject().position, 'y').listen()
  // gui.add(controls.getObject().position, 'z').listen()
  //
  // var clock = new THREE.Clock()
  // function animate() {
  //   requestAnimationFrame( animate );
  //
  //   // var delta = clock.getDelta()
  //
  //   if ( controlsEnabled === true ) {
  //     raycaster.ray.origin.copy( controls.getObject().position );
  //     // raycaster.ray.origin.y -= 2;
  //     var intersections = raycaster.intersectObjects( objects );
  //     var onObject = intersections.length > 0;
  //     var time = performance.now();
  //     // var delta = ( time - prevTime ) / 3000;
  //     var delta = 0.01;
  //     // console.log(delta)
  //     velocity.x -= velocity.x * 10 * delta;
  //     velocity.z -= velocity.z * 10 * delta;
  //     velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
  //     direction.z = Number( moveForward ) - Number( moveBackward );
  //     direction.x = Number( moveLeft ) - Number( moveRight );
  //     direction.normalize(); // this ensures consistent movements in all directions
  //     if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
  //     if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
  //     if ( onObject === true ) {
  //       velocity.y = Math.max( 0, velocity.y );
  //       controls.getObject().position.y = intersections[0].object.position.y + intersections[0].object.scale.y + 1
  //       canJump = true;
  //     }
  //     controls.getObject().translateX( velocity.x * delta );
  //     controls.getObject().translateY( velocity.y * delta );
  //     controls.getObject().translateZ( velocity.z * delta );
  //     // if ( controls.getObject().position.y < 1 ) {
  //     //   velocity.y = 0;
  //     //   controls.getObject().position.y = 1;
  //     //   canJump = true;
  //     // }
  //     prevTime = time;
  //   }
  //
  //   render();
  // }

  </script>
</body>

</html>
