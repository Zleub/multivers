<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

  <title>client</title>
  <meta name="description" content="client description">

  <style>
  body {
    font-family: Monospace;
    background-color: #000;
    color: #fff;
    margin: 0px;
    overflow: hidden;
  }
  #blocker {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }
  #instructions {
    width: 100%;
    height: 100%;
    display: -webkit-box;
    display: -moz-box;
    display: box;
    -webkit-box-orient: horizontal;
    -moz-box-orient: horizontal;
    box-orient: horizontal;
    -webkit-box-pack: center;
    -moz-box-pack: center;
    box-pack: center;
    -webkit-box-align: center;
    -moz-box-align: center;
    box-align: center;
    color: #ffffff;
    text-align: center;
    cursor: pointer;
  }
  </style>

  <script type="text/javascript" src="https://threejs.org/build/three.js"></script>
  <script type="text/javascript" src="FirstPersonControls.js"></script>
  <script type="text/javascript" src="OrbitControls.js"></script>
  <script type="text/javascript" src="PointerLockControls.js"></script>
  <script type="text/javascript" src="keys.js"></script>
  <script type="text/javascript" src="util.js"></script>
  <script type="text/javascript" src="dat.gui.min.js"></script>
</head>
<body>
  <script>
  var run = true
  var objects = []

  var controlsEnabled = false;
  var canJump = false;
  var prevTime = performance.now();
  var velocity = new THREE.Vector3();
  var direction = new THREE.Vector3();
  var camera, scene, renderer, stats;
  var Cubecount = 0

  function render() {
    var time = performance.now() * 0.001;
    renderer.render(scene, camera)
  }

  scene = new THREE.Scene();
  scene.add( new THREE.AmbientLight( 0x6f6f6f ) );

  camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
  var controls = new THREE.PointerLockControls( camera );
  scene.add( controls.getObject() )
  controls.getObject().position.set(0, 10, 0)

  var pointerlockchange = function ( event ) {
      console.log('pointerlockchange')
      controlsEnabled = !controlsEnabled;
      controls.enabled = !controls.enabled;
  };
  document.addEventListener( 'pointerlockchange', pointerlockchange, false );

  renderer = new THREE.WebGLRenderer( { antialias: true } );

  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.BasicShadowMap;
  document.body.appendChild( renderer.domElement );

  var raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, -1, 0 ), 0, 2 );

	document.addEventListener( 'keydown', onKeyDown, false );
	document.addEventListener( 'keyup', onKeyUp, false );
	document.addEventListener( 'keypress', onKeyPress, false );
  //
  var gui = new dat.GUI({name: 'My GUI'});
  gui.add(window, 'run')
  gui.add(window, 'Cubecount').listen()
  //

  gui.add(controls.getObject().position, 'x').listen()
  gui.add(controls.getObject().position, 'y').listen()
  gui.add(controls.getObject().position, 'z').listen()
  //
  var clock = new THREE.Clock()
  function animate() {
    // var delta = clock.getDelta()

    if ( controlsEnabled === true ) {
      raycaster.ray.origin.copy( controls.getObject().position );
      // raycaster.ray.origin.y -= 2;
      var intersections = raycaster.intersectObjects( objects );
      var onObject = intersections.length > 0;
      var time = performance.now();
      // var delta = ( time - prevTime ) / 3000;
      var delta = 0.01;
      // console.log(delta)
      velocity.x -= velocity.x * 10 * delta;
      velocity.z -= velocity.z * 10 * delta;
      velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
      direction.z = Number( keys.up ) - Number( keys.down );
      direction.x = Number( keys.left ) - Number( keys.right );
      direction.normalize(); // this ensures consistent movements in all directions
      if ( keys.up || keys.down ) velocity.z -= direction.z * 400.0 * delta;
      if ( keys.left || keys.right ) velocity.x -= direction.x * 400.0 * delta;
      if ( onObject === true ) {
        velocity.y = Math.max( 0, velocity.y );
        controls.getObject().position.y = intersections[0].object.position.y + intersections[0].object.scale.y + 1
        canJump = true;
      }
      controls.getObject().translateX( velocity.x * delta );
      controls.getObject().translateY( velocity.y * delta );
      controls.getObject().translateZ( velocity.z * delta );
      // if ( controls.getObject().position.y < 1 ) {
      //   velocity.y = 0;
      //   controls.getObject().position.y = 1;
      //   canJump = true;
      // }
      prevTime = time;
    }
    // else {
    //   // document.body.requestPointerLock()
    // }

    render();
    requestAnimationFrame( animate );

  }

  var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
  var materialGray = new THREE.MeshLambertMaterial( {
    color: 0xa0adaf,
    wireframe: false
  } );
  var materialGreen = new THREE.MeshLambertMaterial( {
    color: 0xa0ddaf,
    wireframe: false
  } );
  var materialGreenMore = new THREE.MeshLambertMaterial( {
    color: 0x60bd6f,
    wireframe: false
  } );
  var materialBlue = new THREE.MeshLambertMaterial( {
    color: 0x4d4fd0,
    wireframe: false
  } );

  fetchMultivers('/sharpen').then( res => res.json().then( e => {
    e.add.forEach(_ => {
      var mesh = new THREE.Mesh( geometry, materialGray )

      Cubecount += 1

      mesh.position.x = _.x - e.position[0];
      mesh.position.y = _.y;
      mesh.position.z = _.z - e.position[1];
      mesh.receiveShadow = true;

      // mesh.castShadow = true;
      // mesh.receiveShadow = true;

      scene.add( mesh );
      objects.push( mesh )
    })

    animate()
  }))

  </script>
</body>

</html>
